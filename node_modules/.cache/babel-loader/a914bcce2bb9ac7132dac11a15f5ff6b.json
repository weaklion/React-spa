{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"proxy-polyfill\");\n\nvar utils_1 = require(\"./utils\");\n\nvar PENDING = utils_1.actionTypes.PENDING,\n    SUCCESS = utils_1.actionTypes.SUCCESS,\n    FAILURE = utils_1.actionTypes.FAILURE,\n    CANCEL = utils_1.actionTypes.CANCEL;\nvar _id = 0;\n\nfunction generatePenderId() {\n  _id += 1;\n  return _id;\n}\n\nfunction isPromise(promise) {\n  if (!promise) return false;\n  return promise.then && promise.catch;\n}\n\nfunction getPromise(action, major) {\n  var payload = action.payload;\n  if (!payload) return null;\n\n  if (major) {\n    if (isPromise(payload)) return payload;\n  }\n\n  var pend = action.payload.pend;\n  if (isPromise(pend)) return pend;\n  return null;\n}\n\nfunction penderMiddleware(config) {\n  if (config === void 0) {\n    config = {\n      major: true\n    };\n  }\n\n  var major = config.major === undefined ? true : config.major;\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        // retrieve Promise if possible\n        var promise = getPromise(action, major);\n        if (!promise) return next(action); // skip if no promise found\n\n        var type = action.type,\n            meta = action.meta;\n        var actions = utils_1.penderize(type);\n        var cancelled = false; // promise start\n\n        store.dispatch({\n          type: actions.PENDING,\n          meta: meta\n        }); // inform pender reducer\n\n        store.dispatch({\n          type: PENDING,\n          payload: type\n        }); // use proxy to handle promise cancellation\n\n        var origin = {\n          cancel: false,\n          resolve: false\n        };\n        var proxy = null;\n        var cancelPromise = new Promise(function (resolve, reject) {\n          var handler = {\n            set: function set(target, key, value) {\n              if (key === 'cancel') {\n                cancelled = true;\n                store.dispatch({\n                  type: CANCEL,\n                  payload: type\n                });\n                store.dispatch({\n                  type: actions.CANCEL,\n                  meta: meta\n                });\n                reject(new Error(type + \" is cancelled\"));\n                proxy = null;\n                return true;\n              }\n\n              if (key === 'resolve') {\n                resolve();\n                return true;\n              }\n\n              return true;\n            }\n          };\n          proxy = new Proxy(origin, handler);\n        });\n\n        var cancel = function cancel() {\n          if (!proxy) return;\n          proxy.cancel = true;\n        };\n\n        promise.then(function (result) {\n          if (cancelled) return; // do nothing if cancelled\n\n          if (!proxy) return;\n          proxy.resolve = true;\n          proxy = null; // promise resolved\n\n          store.dispatch({\n            type: actions.SUCCESS,\n            payload: result,\n            meta: meta\n          }); // inform pender reducer\n\n          store.dispatch({\n            type: SUCCESS,\n            payload: type\n          });\n        }).catch(function (e) {\n          if (cancelled) return; // do nothing if cancelled\n\n          if (!proxy) return;\n          proxy.resolve = true;\n          proxy = null; // promise rejected\n\n          store.dispatch({\n            type: actions.FAILURE,\n            payload: e,\n            error: true,\n            meta: meta\n          }); // inform pender reducer\n\n          store.dispatch({\n            type: FAILURE,\n            payload: type\n          });\n        });\n        var cancellablePromise = Promise.race([promise, cancelPromise]);\n        cancellablePromise.cancel = cancel;\n        return cancellablePromise;\n      };\n    };\n  };\n}\n\nexports.default = penderMiddleware;","map":null,"metadata":{},"sourceType":"script"}